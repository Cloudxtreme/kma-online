.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "JSON::Parse 3"
.TH JSON::Parse 3 "2015-07-30" "perl v5.16.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
JSON::Parse \- Read JSON into a Perl variable
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    use JSON::Parse \*(Aqparse_json\*(Aq;
\&    my $json = \*(Aq["golden", "fleece"]\*(Aq;
\&    my $perl = parse_json ($json);
\&    # Same effect as $perl = [\*(Aqgolden\*(Aq, \*(Aqfleece\*(Aq];
.Ve
.PP
Convert \s-1JSON\s0 into Perl.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1JSON\s0 means \*(L"JavaScript Object Notation\*(R" and it is specified in \*(L"\s-1RFC\s0 7159\*(R".
.PP
JSON::Parse converts \s-1JSON\s0 into the nearest equivalent Perl. The
function \*(L"parse_json\*(R" takes one argument, a string containing \s-1JSON\s0,
and returns a Perl reference. The input to \f(CW\*(C`parse_json\*(C'\fR must be a
complete \s-1JSON\s0 structure.
.PP
The module differs from the \s-1JSON\s0 module by simplifying the handling
of Unicode. If its input is marked as Unicode characters, the strings
in its output are also marked as Unicode characters.
.PP
JSON::Parse also provides two high speed validation functions,
\&\*(L"valid_json\*(R" and \*(L"assert_valid_json\*(R", and a function to read \s-1JSON\s0 from
a file, \*(L"json_file_to_perl\*(R".
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "parse_json"
.IX Subsection "parse_json"
.Vb 2
\&    use JSON::Parse \*(Aqparse_json\*(Aq;
\&    my $perl = parse_json (\*(Aq{"x":1, "y":2}\*(Aq);
.Ve
.PP
This function converts \s-1JSON\s0 into a Perl structure, either an array
reference or a hash reference.
.PP
If the first argument does not contain a complete valid \s-1JSON\s0 text,
\&\f(CW\*(C`parse_json\*(C'\fR throws a fatal error (\*(L"dies\*(R"). If the first argument is
the undefined value, an empty string, or a string containing only
whitespace, \f(CW\*(C`parse_json\*(C'\fR returns the undefined value.
.PP
If the argument contains valid \s-1JSON\s0, the return value is either a hash
or an array reference. If the input \s-1JSON\s0 text is a serialized object,
a hash reference is returned:
.PP
.Vb 4
\&    use JSON::Parse \*(Aq:all\*(Aq;
\&    my $perl = parse_json (\*(Aq{"a":1, "b":2}\*(Aq);
\&    print ref $perl, "\en";
\&    # Prints "HASH".
.Ve
.PP
If the input \s-1JSON\s0 text is a serialized array, an array reference is
returned:
.PP
.Vb 4
\&    use JSON::Parse \*(Aq:all\*(Aq;
\&    my $perl = parse_json (\*(Aq["a", "b", "c"]\*(Aq);
\&    print ref $perl, "\en";
\&    # Prints "ARRAY".
.Ve
.SS "json_file_to_perl"
.IX Subsection "json_file_to_perl"
.Vb 2
\&    use JSON::Parse \*(Aqjson_file_to_perl\*(Aq;
\&    my $p = json_file_to_perl (\*(Aqfilename\*(Aq);
.Ve
.PP
This is exactly the same as \*(L"parse_json\*(R" except that it reads the
\&\s-1JSON\s0 from the specified file rather than a scalar. The file must be in
the \s-1UTF\-8\s0 encoding, and is opened as a character file using
\&\f(CW\*(C`:encoding(UTF\-8)\*(C'\fR (see PerlIO::encoding and perluniintro for
details). The output is marked as character strings.
.SS "valid_json"
.IX Subsection "valid_json"
.Vb 4
\&    use JSON::Parse \*(Aqvalid_json\*(Aq;
\&    if (valid_json ($json)) {
\&        # do something
\&    }
.Ve
.PP
\&\f(CW\*(C`Valid_json\*(C'\fR returns \fI1\fR if its argument is valid \s-1JSON\s0 and \fI0\fR if
not. It also returns \fI0\fR if the input is undefined or the empty
string.
.PP
This is a high-speed validator which runs between roughly two and
eight times faster than \*(L"parse_json\*(R".
.PP
\&\f(CW\*(C`Valid_json\*(C'\fR does not supply the actual errors which caused
invalidity. Use \*(L"assert_valid_json\*(R" to get error messages when the
\&\s-1JSON\s0 is invalid.
.SS "assert_valid_json"
.IX Subsection "assert_valid_json"
.Vb 8
\&    use JSON::Parse \*(Aqassert_valid_json\*(Aq;
\&    eval {
\&        assert_valid_json (\*(Aq["xyz":"b"]\*(Aq);
\&    };
\&    if ($@) {
\&        print "Your JSON was invalid: $@\en";
\&    }
\&    # Prints "Unexpected character \*(Aq:\*(Aq parsing array"
.Ve
.PP
This is the underlying function for \*(L"valid_json\*(R". It runs at the
same high speed, but throws an error if the \s-1JSON\s0 is wrong, rather than
returning 1 or 0. See \*(L"\s-1DIAGNOSTICS\s0\*(R" for the error format, which is
identical to \*(L"parse_json\*(R".
.SH "OLD INTERFACE"
.IX Header "OLD INTERFACE"
The following alternative function names are accepted. These are the
names used for the functions in old versions of this module. These
names are not deprecated and will never be removed from the module.
.SS "json_to_perl"
.IX Subsection "json_to_perl"
This is exactly the same function as \*(L"parse_json\*(R".
.SS "validate_json"
.IX Subsection "validate_json"
This is exactly the same function as \*(L"assert_valid_json\*(R".
.SH "Mapping from JSON to Perl"
.IX Header "Mapping from JSON to Perl"
\&\s-1JSON\s0 elements are mapped to Perl as follows:
.SS "\s-1JSON\s0 numbers"
.IX Subsection "JSON numbers"
\&\s-1JSON\s0 numbers become Perl numbers, either integers or double-precision
floating point numbers, or possibly strings containing the number if
parsing of a number by the usual methods fails somehow.
.PP
\&\s-1JSON\s0 does not allow leading zeros, or leading plus signs, so numbers
like \fI+100\fR or \fI0123\fR cause an \*(L"Unexpected character\*(R" error. \s-1JSON\s0
also does not allow numbers of the form \fI1.\fR but it does allow things
like \fI0e0\fR or \fI1E999999\fR. As far as possible these are accepted by
JSON::Parse.
.SS "\s-1JSON\s0 strings"
.IX Subsection "JSON strings"
\&\s-1JSON\s0 strings become Perl strings. The \s-1JSON\s0 escape characters such as
\&\f(CW\*(C`\et\*(C'\fR for the tab character (see section 2.5 of \*(L"\s-1RFC\s0 7159\*(R") are
mapped to the equivalent \s-1ASCII\s0 character.
.PP
\fIHandling of Unicode\fR
.IX Subsection "Handling of Unicode"
.PP
If the input to \*(L"parse_json\*(R" is marked as Unicode characters, the
output strings will be marked as Unicode characters. If the input is
not marked as Unicode characters, the output strings will not be
marked as Unicode characters. Thus,
.PP
.Vb 7
\&    use JSON::Parse \*(Aq:all\*(Aq;
\&    # The scalar $sasori looks like Unicode to Perl
\&    use utf8;
\&    my $sasori = \*(Aq["X"]\*(Aq;
\&    my $p = parse_json ($sasori);
\&    print utf8::is_utf8 ($p\->[0]);
\&    # Prints 1.
.Ve
.PP
but
.PP
.Vb 7
\&    use JSON::Parse \*(Aq:all\*(Aq;
\&    # The scalar $ebi does not look like Unicode to Perl
\&    no utf8;
\&    my $ebi = \*(Aq["XX"]\*(Aq;
\&    my $p = parse_json ($ebi);
\&    print utf8::is_utf8 ($p\->[0]);
\&    # Prints nothing.
.Ve
.PP
Escapes of the form \euXXXX (see page three of \*(L"\s-1RFC\s0 7159\*(R") are mapped
to \s-1ASCII\s0 if \s-1XXXX\s0 is less than 0x80, or to \s-1UTF\-8\s0 if \s-1XXXX\s0 is greater
than or equal to 0x80.
.PP
Strings containing \euXXXX escapes greater than 0x80 are also upgraded
to character strings, regardless of whether the input is a character
string or a byte string, thus regardless of whether Perl thinks the
input string is Unicode, escapes like \eu87f9 are converted into the
equivalent \s-1UTF\-8\s0 bytes and the particular string in which they occur
is marked as a character string:
.PP
.Vb 8
\&    use JSON::Parse \*(Aq:all\*(Aq;
\&    no utf8;
\&    # X
\&    my $kani = \*(Aq["\eu87f9"]\*(Aq;
\&    my $p = parse_json ($kani);
\&    print "It\*(Aqs marked as a character string" if utf8::is_utf8 ($p\->[0]);
\&    # Prints "It\*(Aqs marked as a character string" because it\*(Aqs upgraded
\&    # regardless of the input string\*(Aqs flags.
.Ve
.PP
This is modelled on the behaviour of Perl's \f(CW\*(C`chr\*(C'\fR:
.PP
.Vb 7
\&    no utf8;
\&    my $kani = \*(Aq87f9\*(Aq;
\&    print "hex is character string\en" if utf8::is_utf8 ($kani);
\&    # prints nothing
\&    $kani = chr (hex ($kani));
\&    print "chr makes it a character string\en" if utf8::is_utf8 ($kani);
\&    # prints "chr makes it a character string"
.Ve
.PP
Since every byte of input is validated as \s-1UTF\-8\s0 (see \*(L"\s-1UTF\-8\s0 only\*(R"),
this hopefully will not upgrade invalid strings.
.PP
Surrogate pairs in the form \f(CW\*(C`\euD834\euDD1E\*(C'\fR are also handled. If the
second half of the surrogate pair is missing, an \*(L"Unexpected
character\*(R" or \*(L"Unexpected end of input\*(R" error is thrown. If the
second half of the surrogate pair is present but contains an
impossible value, a \*(L"Not surrogate pair\*(R" error is thrown.
.SS "\s-1JSON\s0 arrays"
.IX Subsection "JSON arrays"
\&\s-1JSON\s0 arrays become Perl array references. The elements of the Perl
array are in the same order as they appear in the \s-1JSON\s0.
.PP
Thus
.PP
.Vb 1
\&    my $p = parse_json (\*(Aq["monday", "tuesday", "wednesday"]\*(Aq);
.Ve
.PP
has the same result as a Perl declaration of the form
.PP
.Vb 1
\&    my $p = [ \*(Aqmonday\*(Aq, \*(Aqtuesday\*(Aq, \*(Aqwednesday\*(Aq ];
.Ve
.SS "\s-1JSON\s0 objects"
.IX Subsection "JSON objects"
\&\s-1JSON\s0 objects become Perl hashes. The members of the \s-1JSON\s0 object become
key and value pairs in the Perl hash. The string part of each object
member becomes the key of the Perl hash. The value part of each member
is mapped to the value of the Perl hash.
.PP
Thus
.PP
.Vb 5
\&    my $j = <<EOF;
\&    {"monday":["blue", "black"],
\&     "tuesday":["grey", "heart attack"],
\&     "friday":"Gotta get down on Friday"}
\&    EOF
\&
\&    my $p = parse_json ($j);
.Ve
.PP
has the same result as a Perl declaration of the form
.PP
.Vb 5
\&    my $p = {
\&        monday => [\*(Aqblue\*(Aq, \*(Aqblack\*(Aq],
\&        tuesday => [\*(Aqgrey\*(Aq, \*(Aqheart attack\*(Aq],
\&        friday => \*(AqGotta get down on Friday\*(Aq,
\&    };
.Ve
.SS "null"
.IX Subsection "null"
The \s-1JSON\s0 null literal is mapped to a readonly scalar
\&\f(CW$JSON::Parse::null\fR containing the undefined value.
.SS "true"
.IX Subsection "true"
The \s-1JSON\s0 true literal is mapped to a readonly scalar
\&\f(CW$JSON::Parse::true\fR containing the value 1.
.SS "false"
.IX Subsection "false"
The \s-1JSON\s0 false literal is mapped to a readonly scalar
\&\f(CW$JSON::Parse::false\fR containing the value 0.
.SH "RESTRICTIONS"
.IX Header "RESTRICTIONS"
This module imposes the following restrictions on its input.
.IP "\s-1JSON\s0 only" 4
.IX Item "JSON only"
JSON::Parse is a strict parser. It only accepts input which exactly
meets the criteria of \*(L"\s-1RFC\s0 7159\*(R". That means, for example,
JSON::Parse does not accept single quotes (') instead of double quotes
("), or numbers with leading zeros, like 0123. JSON::Parse does not
accept control characters (0x00 \- 0x1F) in strings, missing commas
between array or hash elements like \f(CW\*(C`["a" "b"]\*(C'\fR, or trailing commas
like \f(CW\*(C`["a","b","c",]\*(C'\fR. It also does not accept trailing
non-whitespace, like the second \*(L"]\*(R" in \f(CW\*(C`["a"]]\*(C'\fR.
.IP "No incremental parsing" 4
.IX Item "No incremental parsing"
JSON::Parse does not do incremental parsing. JSON::Parse only parses
fully-formed \s-1JSON\s0 strings which include all opening and closing
brackets.
.IP "\s-1UTF\-8\s0 only" 4
.IX Item "UTF-8 only"
Although \s-1JSON\s0 may come in various encodings of Unicode, JSON::Parse
only parses the \s-1UTF\-8\s0 format. If input is in a different Unicode
encoding than \s-1UTF\-8\s0, convert the input before handing it to this
module. For example, for the \s-1UTF\-16\s0 format,
.Sp
.Vb 3
\&    use Encode \*(Aqdecode\*(Aq;
\&    my $input_utf8 = decode (\*(AqUTF\-16\*(Aq, $input);
\&    my $perl = parse_json ($input_utf8);
.Ve
.Sp
or, for a file, use \f(CW\*(C`:encoding\*(C'\fR (see PerlIO::encoding and
perluniintro):
.Sp
.Vb 1
\&    open my $input, "<:encoding(UTF\-16)", \*(Aqsome\-json\-file\*(Aq;
.Ve
.Sp
JSON::Parse does not determine the nature of the octet stream, as
described in part 3 of \*(L"\s-1RFC\s0 7159\*(R".
.Sp
This restriction to \s-1UTF\-8\s0 applies regardless of whether Perl thinks
that the input string is a character string or a byte
string. Non\-UTF\-8 input will cause an \*(L"Unexpected character\*(R" error
to be thrown.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
\&\*(L"valid_json\*(R" does not produce error messages. \*(L"parse_json\*(R" and
\&\*(L"assert_valid_json\*(R" die on encountering invalid input.
.PP
Error messages have the line number and the byte number where
appropriate of the input which caused the problem. The line number is
formed simply by counting the number of \*(L"\en\*(R" (linefeed, \s-1ASCII\s0 0x0A)
characters in the whitespace part of the \s-1JSON\s0.
.PP
Parsing errors are fatal, so to continue after an error occurs, put
the parsing into an \f(CW\*(C`eval\*(C'\fR block:
.PP
.Vb 7
\&    my $p;                       
\&    eval {                       
\&        $p = parse_json ($j);  
\&    };                           
\&    if ($@) {                    
\&        # handle error           
\&    }
.Ve
.PP
The following error messages are produced:
.SS "Unexpected character"
.IX Subsection "Unexpected character"
An unexpected character (byte) was encountered in the input. For
example, when looking at the beginning of a string supposedly
containing \s-1JSON\s0, there are six possible characters, the four \s-1JSON\s0
whitespace characters plus \*(L"[\*(R" and \*(L"{\*(R". If the module encounters a
plus sign, it will give an error like this:
.PP
.Vb 1
\&    assert_valid_json (\*(Aq+\*(Aq);
.Ve
.PP
gives output
.PP
.Vb 1
\&    JSON error at line 1, byte 1/1: Unexpected character \*(Aq+\*(Aq parsing initial state: expecting whitespace: \*(Aq\en\*(Aq, \*(Aq\er\*(Aq, \*(Aq\et\*(Aq, \*(Aq \*(Aq or start of string: \*(Aq"\*(Aq or digit: \*(Aq0\-9\*(Aq or minus: \*(Aq\-\*(Aq or start of an array or object: \*(Aq{\*(Aq, \*(Aq[\*(Aq or start of literal: \*(Aqt\*(Aq, \*(Aqf\*(Aq, \*(Aqn\*(Aq
.Ve
.PP
The message always includes a list of what characters are allowed.
.PP
If there is some recognizable structure being parsed, the error
message will include its starting point in the form \*(L"starting from
byte n\*(R":
.PP
.Vb 1
\&    assert_valid_json (\*(Aq{"this":"\ea"}\*(Aq);
.Ve
.PP
gives output
.PP
.Vb 1
\&    JSON error at line 1, byte 11/13: Unexpected character \*(Aqa\*(Aq parsing string starting from byte 9: expecting escape: \*(Aq\e\*(Aq, \*(Aq/\*(Aq, \*(Aq"\*(Aq, \*(Aqb\*(Aq, \*(Aqf\*(Aq, \*(Aqn\*(Aq, \*(Aqr\*(Aq, \*(Aqt\*(Aq, \*(Aqu\*(Aq
.Ve
.PP
A feature of \s-1JSON\s0 is that parsing it requires only one byte to be
examined at a time. Thus almost all parsing problems can be handled
using the \*(L"Unexpected character\*(R" error type, including spelling errors
in literals:
.PP
.Vb 1
\&    assert_valid_json (\*(Aq[true,folse]\*(Aq);
.Ve
.PP
gives output
.PP
.Vb 1
\&    JSON error at line 1, byte 8/12: Unexpected character \*(Aqo\*(Aq parsing literal starting from byte 7: expecting \*(Aqa\*(Aq
.Ve
.PP
and the missing second half of a surrogate pair:
.PP
.Vb 1
\&    assert_valid_json (\*(Aq["\eudc00? <\-\- should be a second half here"]\*(Aq);
.Ve
.PP
gives output
.PP
.Vb 1
\&    JSON error at line 1, byte 9/44: Unexpected character \*(Aq?\*(Aq parsing unicode escape starting from byte 3: expecting \*(Aq\e\*(Aq
.Ve
.PP
All kinds of errors can occur parsing numbers, for example a missing
fraction,
.PP
.Vb 1
\&    assert_valid_json (\*(Aq[1.e9]\*(Aq);
.Ve
.PP
gives output
.PP
.Vb 1
\&    JSON error at line 1, byte 4/6: Unexpected character \*(Aqe\*(Aq parsing number starting from byte 2: expecting digit: \*(Aq0\-9\*(Aq
.Ve
.PP
and a leading zero,
.PP
.Vb 1
\&    assert_valid_json (\*(Aq[0123]\*(Aq);
.Ve
.PP
gives output
.PP
.Vb 1
\&    JSON error at line 1, byte 3/6: Unexpected character \*(Aq1\*(Aq parsing number starting from byte 2: expecting whitespace: \*(Aq\en\*(Aq, \*(Aq\er\*(Aq, \*(Aq\et\*(Aq, \*(Aq \*(Aq or comma: \*(Aq,\*(Aq or end of array: \*(Aq]\*(Aq or dot: \*(Aq.\*(Aq or exponential sign: \*(Aqe\*(Aq, \*(AqE\*(Aq
.Ve
.PP
The error message is this complicated because all of the following are
valid here: whitespace: \f(CW\*(C`[0 ]\*(C'\fR; comma: \f(CW\*(C`[0,1]\*(C'\fR, end of array:
\&\f(CW\*(C`[0]\*(C'\fR, dot: \f(CW\*(C`[0.1]\*(C'\fR, or exponential: \f(CW\*(C`[0e0]\*(C'\fR.
.PP
These are all handled by this error.  Thus the error messages are a
little confusing as diagnostics.
.PP
Versions of this module prior to 0.29 gave more informative messages
like \*(L"leading zero in number\*(R". (The messages weren't documented.) The
reason to change over to the single message was because it makes the
parsing code simpler, and because the testing code described in
\&\*(L"\s-1TESTING\s0\*(R" makes use of the internals of this error to check that the
error message produced actually do correspond to the invalid and valid
bytes allowed by the parser, at the exact byte given.
.PP
This is a bytewise error, thus for example if a miscoded \s-1UTF\-8\s0 appears
in the input, an error message saying what bytes would be valid at
that point will be printed.
.PP
.Vb 2
\&    no utf8;
\&    use JSON::Parse \*(Aqassert_valid_json\*(Aq;
\&    
\&    # Error in first byte:
\&    
\&    my $bad_utf8_1 = chr (hex ("81"));
\&    eval { assert_valid_json ("[\e"$bad_utf8_1\e"]"); };
\&    print "$@\en";
\&    
\&    # Error in third byte:
\&    
\&    my $bad_utf8_2 = chr (hex (\*(Aqe2\*(Aq)) . chr (hex (\*(Aq9C\*(Aq)) . \*(Aqb\*(Aq;
\&    eval { assert_valid_json ("[\e"$bad_utf8_2\e"]"); };
\&    print "$@\en";
.Ve
.PP
prints
.PP
.Vb 1
\&    JSON error at line 1, byte 3/5: Unexpected character 0x81 parsing string starting from byte 2: expecting printable ASCII or first byte of UTF\-8: \*(Aq\ex20\-\ex7f\*(Aq, \*(Aq\exC2\-\exF4\*(Aq at examples/bad\-utf8.pl line 10.
\&    
\&    JSON error at line 1, byte 5/7: Unexpected character \*(Aqb\*(Aq parsing string starting from byte 2: expecting bytes in range 80\-bf: \*(Aq\ex80\-\exbf\*(Aq at examples/bad\-utf8.pl line 16.
.Ve
.SS "Unexpected end of input"
.IX Subsection "Unexpected end of input"
The end of the string was encountered before the end of whatever was
being parsed was. For example, if a quote is missing from the end of
the string, it will give an error like this:
.PP
.Vb 1
\&    assert_valid_json (\*(Aq{"first":"Suzuki","second":"Murakami","third":"Asada}\*(Aq);
.Ve
.PP
gives output
.PP
.Vb 1
\&    JSON error at line 1: Unexpected end of input parsing string starting from byte 47
.Ve
.SS "Not surrogate pair"
.IX Subsection "Not surrogate pair"
While parsing a string, a surrogate pair was encountered. While trying
to turn this into \s-1UTF\-8\s0, the second half of the surrogate pair turned
out to be an invalid value.
.PP
.Vb 1
\&    assert_valid_json (\*(Aq["\euDC00\euABCD"]\*(Aq);
.Ve
.PP
gives output
.PP
.Vb 1
\&    JSON error at line 1: Not surrogate pair parsing unicode escape starting from byte 11
.Ve
.SS "Empty input"
.IX Subsection "Empty input"
This error occurs for \*(L"assert_valid_json\*(R" when it's given an empty
or undefined value. Given empty input, \*(L"parse_json\*(R" returns an
undefined value rather than throwing an error.
.SH "SPEED"
.IX Header "SPEED"
On the author's computer, the module's speed of parsing is
approximately the same as \s-1JSON::XS\s0, with small variations depending
on the type of input. For validation, \*(L"valid_json\*(R" is faster than
any other module known to the author, and up to ten times faster than
\&\s-1JSON::XS\s0.
.PP
Some special types of input, such as floating point numbers containing
an exponential part, like \*(L"1e09\*(R", seem to be about two or three times
faster to parse with this module than with \s-1JSON::XS\s0. In
JSON::Parse, parsing of exponentials is done by the system's \f(CW\*(C`strtod\*(C'\fR
function, but \s-1JSON::XS\s0 contains its own parser for exponentials, so
these results may be system-dependent.
.PP
On the other hand, \s-1JSON::XS\s0 makes better use of Perl's inbuilt string
handling than JSON::Parse and so it's faster for some types of
strings. The main focus of the version 0.29 release is increased
accuracy and better handling of edge cases. I'm planning to attend to
the speed issues in future versions.
.PP
There is some benchmarking code in the github repository under the
directory \*(L"benchmarks\*(R" for those wishing to test these claims. The
script \fIbenchmarks/bench\fR is an adaptation of the similar script in
the \s-1JSON::XS\s0 distribution.
.PP
The following benchmark tests used version 0.29 of JSON::Parse and
version 3.01 of \s-1JSON::XS\s0 on the files in the \*(L"benchmarks\*(R" directory of
JSON::Parse. \*(L"short.json\*(R" and \*(L"long.json\*(R" are the benchmarks used by
\&\s-1JSON::XS\s0.
.IP "short.json" 4
.IX Item "short.json"
.Vb 8
\&    Repetitions: 10 x 100 = 1000
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
\&    module        |      1/min |        min |
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-|
\&    JP::valid     | 358487.521 |  0.0000279 |
\&    JSON::Parse   | 179243.761 |  0.0000558 |
\&    JSON::XS      | 156503.881 |  0.0000639 |
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.IP "long.json" 4
.IX Item "long.json"
.Vb 8
\&    Repetitions: 10 x 100 = 1000
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
\&    module        |      1/min |        min |
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-|
\&    JP::valid     |   6385.968 |  0.0015659 |
\&    JSON::Parse   |   2803.492 |  0.0035670 |
\&    JSON::XS      |   3506.357 |  0.0028520 |
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.IP "words\-array.json" 4
.IX Item "words-array.json"
.Vb 8
\&    Repetitions: 10 x 100 = 1000
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
\&    module        |      1/min |        min |
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-|
\&    JP::valid     | 164482.510 |  0.0000608 |
\&    JSON::Parse   |  22622.999 |  0.0004420 |
\&    JSON::XS      |  21936.736 |  0.0004559 |
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.IP "exp.json" 4
.IX Item "exp.json"
.Vb 8
\&    Repetitions: 10 x 100 = 1000
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
\&    module        |      1/min |        min |
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-|
\&    JP::valid     |  88487.426 |  0.0001130 |
\&    JSON::Parse   |  35726.610 |  0.0002799 |
\&    JSON::XS      |  13662.228 |  0.0007319 |
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.IP "literals.json" 4
.IX Item "literals.json"
.Vb 8
\&    Repetitions: 10 x 100 = 1000
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
\&    module        |      1/min |        min |
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-|
\&    JP::valid     | 204600.195 |  0.0000489 |
\&    JSON::Parse   |  31230.856 |  0.0003202 |
\&    JSON::XS      |  17578.810 |  0.0005689 |
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.IP "cpantesters.json" 4
.IX Item "cpantesters.json"
.Vb 8
\&    Repetitions: 10 x 100 = 1000
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
\&    module        |      1/min |        min |
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-|
\&    JP::valid     |    631.187 |  0.0158432 |
\&    JSON::Parse   |    132.401 |  0.0755279 |
\&    JSON::XS      |    131.020 |  0.0763240 |
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\s-1RFC\s0 7159" 4
.IX Item "RFC 7159"
\&\s-1JSON\s0 is specified in \s-1RFC\s0 7159 \*(L"The application/json Media Type for
JavaScript Object Notation
(\s-1JSON\s0)\*(R" <http://www.ietf.org/rfc/rfc7159.txt>.
.IP "json.org" 4
.IX Item "json.org"
<http://json.org> is the website for \s-1JSON\s0, authored by Douglas
Crockford.
.IP "\s-1JSON\s0, \s-1JSON::XS\s0, and friends" 4
.IX Item "JSON, JSON::XS, and friends"
These modules allow both reading and writing of \s-1JSON\s0. JSON::Parse
originated as a response to the overcomplex interface of \s-1JSON\s0, in
particular its exasperating handling of Unicode.
.Sp
There are also a lot of other modules for parsing and producing \s-1JSON\s0
on \s-1CPAN\s0. I have found the following ones: \s-1JSON::DWIW\s0, JSON::Any,
\&\s-1JSON::YAJL\s0, JSON::Util, JSON::Tiny, Pegex::JSON,
JSON::Streaming::Reader, JSON::Syck, Mojo::JSON,
\&\s-1JSON::SL\s0. Please let me know of any others I've missed.
.Sp
A fork of \s-1JSON::XS\s0 also exists as Cpanel::JSON::XS. This is related
to a disagreement about how to report bugs. Please see the module for
details. Another module, JSON::XS::VersionOneAndTwo, supports two
different interfaces of \s-1JSON::XS\s0. However, \s-1JSON::XS\s0 is now onto
version 3.
.SH "TEST RESULTS"
.IX Header "TEST RESULTS"
The \s-1CPAN\s0 testers results are at the usual place. At the time of
release of this 0.29 version of the module, apart from pre\-5.8.9
versions of Perl, there is only one \s-1CPAN\s0 testers testing machine on
which JSON::Parse fails its tests, a Windows 5.16.3 multithreaded
Perl. So far I have been unable to work out why these tests are
failing on that machine. If JSON::Parse does not install on your
machine, let me know.
.PP
The ActiveState test results are at
http://code.activestate.com/ppm/JSON\-Parse/ <http://code.activestate.com/ppm/JSON-Parse/>.
.SH "EXPORTS"
.IX Header "EXPORTS"
The module exports nothing by default. All of the functions,
\&\*(L"parse_json\*(R", \*(L"json_file_to_perl\*(R", \*(L"valid_json\*(R" and
\&\*(L"assert_valid_json\*(R", as well as the old function names
\&\*(L"validate_json\*(R" and \*(L"json_to_perl\*(R", can be exported on request.
.PP
All of the functions can be exported using the tag ':all':
.PP
.Vb 1
\&    use JSON::Parse \*(Aq:all\*(Aq;
.Ve
.SH "TESTING"
.IX Header "TESTING"
The module incorporates extensive testing related to the production of
error messages and validation of input. Some of the testing code is
supplied with the module in the \fI/t/\fR subdirectory of the
distribution.
.PP
More extensive testing code is in the git repository. This is not
supplied in the \s-1CPAN\s0 distribution. A script, \fIrandomjson.pl\fR,
generates a set number of bytes of random \s-1JSON\s0 and checks that the
module's bytewise validation of input is correct. This setup relies on
a C file \fIjson\-random\-test.c\fR which isn't in the \s-1CPAN\s0 distribution,
and it also requires \fIJson3.xs\fR to be edited to make the macro
\&\f(CW\*(C`TESTRANDOM\*(C'\fR true (uncomment line 7 of the file). The testing code
uses C setjmp/longjmp, so it's not guaranteed to work on all operating
systems and is commented out for \s-1CPAN\s0 releases.
.PP
A pure C version called \fIrandom\-test.c\fR also exists. This applies
exactly the same tests, and requires no Perl at all.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ben Bullock, <bkb@cpan.org>
.SH "LICENSE"
.IX Header "LICENSE"
JSON::Parse can be used, copied, modified and redistributed under the
same terms as Perl itself.
